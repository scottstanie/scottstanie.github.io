<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Solitaire Chess in Python.</title>
     <link rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <style type="text/css" media="screen">
      body {
        background:white; color:#020202;
        font:1.5rem georgia, serif;
        line-height:1.4;
        font-weight: lighter;
        text-rendering: optimizelegibility;
      }
      div.breaker { clear:both; }
      img { border:none; vertical-align:bottom; }
      hr { height:1px; border:none; background-color:#ddd; }
      h1,h2,h3,h4 {
        font-family: 'Helvetica Neue', helvetica, sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      #content {
        padding:20px;
      }
      table {
  margin:0;padding:0;
  width:100%;
  box-shadow: 10px 10px 5px #888888;
  border:1px solid #000000;

  -moz-border-radius-bottomleft:0;
  -webkit-border-bottom-left-radius:0;
  border-bottom-left-radius:0;
}

    </style>
  </head>
  <body>
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Scott Staniewicz</a>
    </div>
    <div>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/">Home</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
    </div>
  </div>
</nav>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div id="content">
      <h1>Breadth First Search in Solitaire Chess</h1>

<p>Here is an example of Breadth First Search (BFS) to traverse a graph and find all possible paths. The graph here is a representation of a 4x4 chess board in the game of <a href="http://www.thinkfun.com/microsite/solitairechess/demo">solitaire chess</a>. The pieces are standard chess pieces. The only legal moves are captures of other pieces. Pawns only being able to move downward.<br/>
The board starts in a random configuration, and the objective of the puzzle is to be left with only one piece.<br/>
An interesting programming problem related to this game: Create a program that can accept an arbitrary board state as input and determine if there is a solution. If there are solutions, print out all steps for each one.<br/>
The steps to programming this solution are as follows:
1. Create classes for each type of piece, with methods for the available move directions that test for boundaries
2. Create a class for the board state with the methods to find all available moves from the current state. Include an attribute for marking the parent of the board state- that is, which board came before the current one, with <code>None</code> as the parent of the starting board.
3. For the BFS, create a queue (from <code>collections.deque</code>) to store the board states for testing each one. As new board states are found from each one tested, push them on to the back of the queue.</p>

<p>The actual BFS algorithm looks like this, where <code>Board_state.size()</code> is a method to list how many pieces are left on the board, and <code>Board_state.win_paths</code> is list of the indices to keep track of which winning paths the state was a part of.</p>

<pre><code>def run_BFS(start_board, queue):
    all_boards = []
    win_idx = 0

    queue.append(start_board)

    while len(queue) &gt; 0:
        cur = queue.popleft()
        all_boards.append(cur)

        if cur.size() &gt; 1:
            new_boards = cur.find_all_captures()
            queue.extend(new_boards)
        else:
            cur.win_paths.append(win_idx)
            win_idx += 1

    num_strategies = win_idx

    return all_boards, num_strategies
</code></pre>

<p>If we were to use Depth First Search (DFS), the algorithm would look like this:</p>

<pre><code>def run_DFS(start_board, stack):
    stack.append(start_board)

    all_boards = []
    win_idx = 0

    while len(stack) &gt; 0:
        cur = stack.pop()
        all_boards.append(cur)

        if cur.size() &gt; 1:
            new_boards = cur.find_all_captures()
            stack.extend(new_boards)
        else:
            cur.win_paths.append(win_idx)
            win_idx += 1

    num_strategies = win_idx

    return all_boards, num_strategies
</code></pre>

<p>The main difference here is that we are using stack instead of a queue, though in python they can be the same data structure- a deque. The deque and a normal <code>list</code> would be the same here, as we are simply popping graph nodes on top of the stack and removing one at each iteration.<br/>
The difference in DFS is that the nodes that were most recently placed on top are examined first, leading to some solution along a path quicker. If we were to stop at the first possible solution, DFS would be usually be quicker (unless the one solution were the last branch of the graph).</p>

    </div>
  </body>
</html>
