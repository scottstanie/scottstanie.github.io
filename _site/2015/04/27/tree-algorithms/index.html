<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Tree Algorithms</title>
     <link rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <style type="text/css" media="screen">
      body {
        background:white; color:#020202;
        font:1.5rem georgia, serif;
        line-height:1.4;
        font-weight: lighter;
        text-rendering: optimizelegibility;
      }
      div.breaker { clear:both; }
      img { border:none; vertical-align:bottom; }
      hr { height:1px; border:none; background-color:#ddd; }
      h1,h2,h3,h4 {
        font-family: 'Helvetica Neue', helvetica, sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      #content {
        padding:20px;
      }
      table {
  margin:0;padding:0;
  width:100%;
  box-shadow: 10px 10px 5px #888888;
  border:1px solid #000000;

  -moz-border-radius-bottomleft:0;
  -webkit-border-bottom-left-radius:0;
  border-bottom-left-radius:0;
}

.header-link {
  position: absolute;
  left: 0em;
  opacity: 0;

  -webkit-transition: opacity 0.2s ease-in-out 0.1s;
  -moz-transition: opacity 0.2s ease-in-out 0.1s;
  -ms-transition: opacity 0.2s ease-in-out 0.1s;
}

h2:hover .header-link,
h3:hover .header-link,
h4:hover .header-link,
h5:hover .header-link,
h6:hover .header-link {
  opacity: 1;
}



      .hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */

    </style>
  </head>
  <body>
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Scott Staniewicz</a>
    </div>
    <div>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/">Home</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
    </div>
  </div>
</nav>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div id="content">
      <h1 id="trees-and-tree-algorithms">Trees and Tree algorithms</h1>

<p>Heaps and Binary search trees (BST) are two variations of a general binary tree. A binary tree is simply a linked data structure where each node is an object. Every node contains the attributes a <em>parent</em>, <em>left child</em>, and <em>right child</em>. The children may be null is the nodes are leaves of the tree, and the parent is null for the root. Heaps and BSTs are binary trees that have certain special ordering properties that make them useful.</p>

<h2 id="binary-heaps">Binary Heaps</h2>

<p>What is a binary heap? It is simply a binary tree that is:<br />
- <strong><em>Complete</em></strong>: Every level is filled, except possibly the bottom (which gets filled in left to right)<br />
- <strong><em>Satisfies</em></strong> the <em>heap order property</em>, which means for a min/ max heap that every node is less/ greater than or equal to its children</p>

<p>The heap order property leads to a few interesting characteristics:<br />
- The root node is always the smallest (largest for max heap)<br />
- Any path down a subtree is sorted, but different subtrees may not be sorted relative to each other (see below)</p>

<p><img src="http://i.imgur.com/tclAVS3.png" alt="Drawing" style="width: 300px;" />
<img src="http://i.imgur.com/5goc4AX.png" alt="Drawing" style="width: 300px;" /></p>

<h2 id="priority-queues">Priority Queues</h2>

<p>To understand why we might use a binary head, letâ€™s examine what a <strong>priority queue</strong> is.
A <em>priority queue</em> is an abstract data type that is used in many different problems: essentially, anywhere that would require a queue, but also have a need to serve high priority items before lower priority items. Examples include operating systems, where jobs are scheduled according to priority, or doctors in the ER taking patients according to severity of injuries. It is first in first out (FIFO) similar to a queue, but high priority items are inserted near the front.<br />
Priority queues can be implemented with a heap, which have several advantages over other data structures which might be used. Below shows a table that outlines the run times of <code class="highlighter-rouge">find_min</code> and <code class="highlighter-rouge">insert</code> for these data structures:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Data Structure</th>
      <th style="text-align: center"><code class="highlighter-rouge">insert</code></th>
      <th style="text-align: right"><code class="highlighter-rouge">find_min</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">List- sorted)</td>
      <td style="text-align: center">O(1)</td>
      <td style="text-align: right">O(n)</td>
    </tr>
    <tr>
      <td style="text-align: left">List- unsorted)</td>
      <td style="text-align: center">O(n)</td>
      <td style="text-align: right">O(1))</td>
    </tr>
    <tr>
      <td style="text-align: left">BST</td>
      <td style="text-align: center">O(log n)</td>
      <td style="text-align: right">O(log n))</td>
    </tr>
    <tr>
      <td style="text-align: left">Heap</td>
      <td style="text-align: center">O(log n)</td>
      <td style="text-align: right">O(1)</td>
    </tr>
  </tbody>
</table>

<p><br />
The BST (explored further below) option is good for different applications where all finds need to be quick. The Binary heap however is quicker when only <code class="highlighter-rouge">find_min</code> will be used.</p>

<p>Another point about the binary heap is that it can be implemented using only an array.  Even though it is best visualized with a graph, no special node structure is needed. There are two reasons for this:<br />
- Each layer of the heap is ordered
- For each layer <em>i</em> (except the bottom) there will <em>always</em> be 2^i items</p>

<p>In the array, each layer will be a slice of size 2^i. The binary heap pictured above will look as follows in an array:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>H = [0, 5, 10, 94, 97, 24]
</code></pre>
</div>

<p>Finding the root simple: <code class="highlighter-rouge">H[1]</code>. The left and right child of node at index <em>i</em> will be located at \(2\times i \) and \(2\times i + 1\), respectively. This also means that the parent of node <em>i</em> is <code class="highlighter-rouge">i // 2</code>, where <code class="highlighter-rouge">//</code> denotes integer division.</p>

<h3 id="heap-operations">Heap Operations</h3>

<p>Clearly finding the min is easy (<code class="highlighter-rouge">H[1]</code>). What about inserting into the heap? The obvious first step would be appending to the end of the list. This would maintain the <em>complete</em> property of the heap, but probably not maintain the well ordered property. Therefore, we must <em>percolate up</em> the new node until it fits satisfies the ordering property.<br />
This really just involves comparing the inserted node to each of its parents up the subtree until one is found that is smaller. We can use the division techniques described about. So, for inserting <code class="highlighter-rouge">7</code> into the array H above the percolation steps are:</p>

<div class="highlighter-rouge"><pre class="highlight"><code># Index of 7 is 6 -&gt; the parent is index 6 // 2 = 3
H = [0, 5, 10, 94, 97, 24, 7]

# 94 &gt; 7, swap the two entries. 
H = [0, 5, 10, 7, 97, 24, 94]

# Check new parent index at 3 // 2 = 1
# H[1] = 5, and 5 &lt;= 7, so the heap order is satisfied
H = [0, 5, 10, 7, 97, 24, 94]
</code></pre>
</div>

<p>This can be coded as:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def percolate_up(H, idx):
    while idx &gt; 0:
        if H[idx] &gt; H[idx // 2]:
            # Swap parent and child nodes
            H[idx], H[idx // 2] = H[idx // 2], H[idx]

        idx = idx // 2
</code></pre>
</div>

<p>The run time of this insertion is \(log(n) \) due to the divisions by 2.<br />
What about deleting the min node at the top of the heap? What we can do is replace it with the last item in the list, then create a procedure similar to the previous one to restore the heap order. First, we make a helper function to find the index of the smaller of a nodeâ€™s two children:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def min_child(self, idx):
    '''Returns the index of the minimum child of the node
    at idx.'''
    # If there are not two children, return the index of the left child
    if 2*idx + 1 &gt; self.size:
        return idx * 2
    else:
        # Check the right child first
        if self.heap_list[idx] &lt; self.heap_list[2*idx + 1]:
            return 2*idx
        else:
            return 2*idx + 1
</code></pre>
</div>

<p>Then, after popping the last item off the array and inserting it at the front, the function <code class="highlighter-rouge">percolate_down</code> might look like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def percolate_down(self):
    idx = 1
    while idx * 2 &lt; self.size:
        min_idx = self.min_child(idx)
        if self.heap_list[idx] &gt; self.heap_list[min_idx]:
            self.swap_nodes(idx, min_idx)
        idx = min_idx
</code></pre>
</div>

<p>With these opearations to maintain the heap structure, implementing a priority queue is straightforward.</p>

<h2 id="binary-search-trees">Binary search trees</h2>

<p>What is a binary search tree? It is quite similar to a binary heap, with slightly different ordering of the nodes. The <strong><em>binary-search-tree</em></strong> property is the following: If x is a node in a BST, then for any node <code class="highlighter-rouge">r</code> in the right subtree of x and any node <code class="highlighter-rouge">l</code> in the left subtree, either \(l &lt;= x\) or \(r &gt;= x\)</p>

<p>This means ordering of a BST allows us to search through or print the node values quickly and in a simple recursive way.
### Tree Operations
To print the values of the tree in order, we use a function <code class="highlighter-rouge">in_order_walk</code> that looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def in_order_walk(node):
  if node is not None:
    in_order_walk(node.left)
    print node
    in_order_walk(node.right)
</code></pre>
</div>

<h4 id="searching">Searching</h4>
<p>If we are looking for <code class="highlighter-rouge">k</code> in a BST <code class="highlighter-rouge">b</code>, the search algorithm looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def search(node, k):
  if node is None or node == k:
    return node
  if x &lt;= node:
    return search(node.left, k)
  else:
    return search(node.right, k)
</code></pre>
</div>

<p>If we call <code class="highlighter-rouge">search(b.root, k)</code>, the entire tree will be searched. The function only looks down half of the tree at each point, which means that it runs in O(log n). The above recursive procedure can also be rewritten iteratively:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def search(node, k):
  while node is not None and node != k:
    if node &lt;= k:
      node = node.left
    else:
      node = node.right
  return node
</code></pre>
</div>

<p>This is usually more efficient than the recursive form.<br />
Finding the minimum and maximum of the tree is straightforward as well:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def find_max(node):
  while node.left is not None:
    node = node.left
  return node

def find_min(node):
  while node.right is not None:
    node = node.right
  return node
</code></pre>
</div>

<p>A <em>successor</em> of a node <code class="highlighter-rouge">x</code> is the smallest tree node with a key <em>greater</em> than <code class="highlighter-rouge">x.key</code>. To find this, we must consider the two cases of whether the right subtree of x is or is not null. The algorithm looks like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def find_successor(x):
  if x.right is not None:
    return find_min(x)
  else:
    y = x.parent
    while y is not None and y.right == x:
      x = y
      y = x.parent
    return y
</code></pre>
</div>

<p>The case of a non-null right subtree is simple: the right child will be larger than <code class="highlighter-rouge">x</code>, so finding the minimum of the right subtree returns the minimum node greater than <code class="highlighter-rouge">x</code>.<br />
For the other case, we must traverse up the tree. The successor will appear as the first ancestor for which the current node is not the right child. If we take <code class="highlighter-rouge">y</code> as the parent and find that x is the left child (so <code class="highlighter-rouge">y.right != x</code>), this means that y is greater than x, and thus is the successor. If <code class="highlighter-rouge">y</code> becomes <code class="highlighter-rouge">None</code>, that means that there is no successor- the node is the largest in the tree.</p>

<h4 id="insertion">Insertion</h4>

<p>Inserting a new node <code class="highlighter-rouge">z</code> into the tree <code class="highlighter-rouge">T</code> requires us to traverse down the tree and insert it at some leaf.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def insert_node(T, z):
  x = T.root  # Start at the root
  y = None  # The leaf that we will insert under
  while x is not None:
    y = x
    if z.key &lt; x.key:
      x = x.left
    else:
      x = x.right

    z.parent = y
    if y is None:
      T.root = z  # If the tree was empty

    if z.key &lt; y.key:
      y.left = z
    else:
      y.right = z  
</code></pre>
</div>

<h4 id="deletion">Deletion</h4>
<p>For deleting a node <code class="highlighter-rouge">z</code> from a tree <code class="highlighter-rouge">T</code>, there are 3 basic cases to consider:
- <code class="highlighter-rouge">z</code> has no children: simply delete <code class="highlighter-rouge">z</code>
- <code class="highlighter-rouge">z</code> has one child: delete z and replace the z with the subtree of its child
- <code class="highlighter-rouge">z</code> has two children: First, find <code class="highlighter-rouge">y</code>, the successor of <code class="highlighter-rouge">z</code>, which will be in the right subtree. Then consider two subcases:
  - If the <code class="highlighter-rouge">y</code> is equal to the right child of <code class="highlighter-rouge">z</code>, just replace <code class="highlighter-rouge">z</code> right the subtree at <code class="highlighter-rouge">y</code>
  - Otherwise, move the <code class="highlighter-rouge">y</code> right child of to where <code class="highlighter-rouge">y</code> was located, then replace <code class="highlighter-rouge">z</code> with <code class="highlighter-rouge">y</code></p>

<p>This last subcase must be considered because we need to merge the two subtrees in a way that preserves the binary search property.</p>

    </div>
    <div id="footer">
      <script>
      $(function() {
  return $("h2, h3, h4, h5, h6").each(function(i, el) {
    var $el, icon, id;
    $el = $(el);
    id = $el.attr('id');
    icon = '<i class="fa fa-link"></i>';
    if (id) {
      return $el.prepend($("<a />").addClass("header-link").attr("href", "#" + id).html(icon));
    }
  });
});

      </script>
    </div>
  </body>
</html>
