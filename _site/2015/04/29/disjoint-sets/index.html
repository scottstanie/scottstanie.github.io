<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Disjoint Sets</title>
     <link rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <style type="text/css" media="screen">
      body {
        background:white; color:#020202;
        font:1.5rem georgia, serif;
        line-height:1.4;
        font-weight: lighter;
        text-rendering: optimizelegibility;
      }
      div.breaker { clear:both; }
      img { border:none; vertical-align:bottom; }
      hr { height:1px; border:none; background-color:#ddd; }
      h1,h2,h3,h4 {
        font-family: 'Helvetica Neue', helvetica, sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      #content {
        padding:20px;
      }
      table {
  margin:0;padding:0;
  width:100%;
  box-shadow: 10px 10px 5px #888888;
  border:1px solid #000000;

  -moz-border-radius-bottomleft:0;
  -webkit-border-bottom-left-radius:0;
  border-bottom-left-radius:0;
}

    </style>
  </head>
  <body>
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Scott Staniewicz</a>
    </div>
    <div>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/">Home</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
    </div>
  </div>
</nav>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div id="content">
      <h1>The Disjoin Set Data Structure</h1>

<p>For some problems that require effeciency in memory or run time, solutions that involve Breadth First Search may be replaced with the disjoin set data structure.<br/>
First, what is this data structure? It is simply a collection of disjoint sets \(S_1, S_2, ... , S_n\) that may be added to or removed from. Additionally, each set contains a <em>representative</em>, which is just some member from the set. For out examples, we will use the largest member. As a reminder, a set, informally, is just an <em>unordered</em> group of <em>unique</em> of things. Two sets are disjoint if they contain no members in common. E.g. {1, 3, 4} and {2, 5} are disjoint, but {1, 3, 4} and {1, 5} are not.<br/>
To see how it might be use, let's look at an example scenario. Imaging there are a group of 5 of people hanging out called A, B, C, D, and E. At the start, {A}, {B}, {C}, {D}, {E} are all disjoint sets.<br/>
Through the night, some become friends with each other, some do not. If A and B are friends {A, B} is now one of the disjoint sets, with {C}, {D}, {E} being the others. D and E become friends, which makes the sets {A, B}, {D, E}, and {E}. Finally, if B and D become friends, the two sets of two merge, so the final sets are {A, B, D, E}, and {C}.<br/>
To check if two people are in the same group, we check their set representative. The representative of the set with person A is the same as that with E, so they are in the same set.</p>

<p>We can define some functions for disjoint sets.</p>

<ul>
<li><code>create_set(x)</code> - forms a set with one element, x</li>
<li><code>merge_sets(x,y)</code> - merges the set that contains x and that which contains y into one new set, destroying the old set</li>
<li><code>find_set(x)</code> - returns the representative of the set containing x</li>
</ul>


<p>To set up our scenario using these functions, the code looks like this:</p>

<pre><code># Gather the input of people in a list P [p1, p2, ... pn]
for p in P:
  create_set(p)
for (x, y) in friend_tuples:
  if find_set(x) != find_set(y):
    merge_sets(x, y)
</code></pre>

<p>Now we can just check <code>find_set(x) == find_set(y)</code> to see if <code>x</code> and <code>y</code> are friends.</p>

    </div>
  </body>
</html>
