<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Classes in Python</title>
     <link rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <style type="text/css" media="screen">
      body {
        background:white; color:#020202;
        font:1.5rem georgia, serif;
        line-height:1.4;
        font-weight: lighter;
        text-rendering: optimizelegibility;
      }
      div.breaker { clear:both; }
      img { border:none; vertical-align:bottom; }
      hr { height:1px; border:none; background-color:#ddd; }
      h1,h2,h3,h4 {
        font-family: 'Helvetica Neue', helvetica, sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      #content {
        padding:20px;
      }
      table {
  margin:0;padding:0;
  width:100%;
  box-shadow: 10px 10px 5px #888888;
  border:1px solid #000000;

  -moz-border-radius-bottomleft:0;
  -webkit-border-bottom-left-radius:0;
  border-bottom-left-radius:0;
}

.header-link {
  position: absolute;
  left: 0em;
  opacity: 0;

  -webkit-transition: opacity 0.2s ease-in-out 0.1s;
  -moz-transition: opacity 0.2s ease-in-out 0.1s;
  -ms-transition: opacity 0.2s ease-in-out 0.1s;
}

h2:hover .header-link,
h3:hover .header-link,
h4:hover .header-link,
h5:hover .header-link,
h6:hover .header-link {
  opacity: 1;
}



      .hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */

    </style>
  </head>
  <body>
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Scott Staniewicz</a>
    </div>
    <div>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/">Home</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
    </div>
  </div>
</nav>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div id="content">
      <h1 id="classes-in-python">Classes in Python</h1>

<p>First, what is a class?<br>
A class is simply a logical grouping of data and functions. It is really a modelling technique used in the organization of programs, and it is a fundamental part of <strong><em>object oriented programming (OOP)</em></strong>.<br>
Defining a class is defining a blueprint for creating objects, and in python, <a href="https://pythoninternal.wordpress.com/2014/08/11/everythings-an-object/">everything is an <strong>object</strong></a>.  </p>

<h3 id="object-oriented-terminology">Object Oriented Terminology</h3>

<p>First, let&#39;s go over the basic terms used in OOP.  </p>

<ul>
<li><p><strong>Class</strong>: A user-defined <em>prototype</em> for an object that defines a set of features that characterize any object of the class. The features are <strong>data members</strong> (class variables and instance variables) and <strong>methods</strong>, accessed via dot notation.</p></li>
<li><p><strong>Attribute</strong>: A class variable or instance variable that holds data associated with a class and its objects.</p>

<ul>
<li>Note that in OOP terminology,  &quot;attributes&quot;, &quot;fields&quot;, and &quot;variables&quot; are often used interchangeably.<br></li>
</ul></li>
<li><p><strong>Method</strong>: A special kind of function that is defined in a class definition.</p></li>
<li><p><strong>Member</strong>: A term to describe either class methods or attributes</p></li>
<li><p><strong>Instance</strong>: An individual object of a certain class. An object obj that belongs to a class Circle, for example, is an instance of the class Circle.</p></li>
<li><p><strong>Instantiation</strong>: The creation of an instance of a class.</p></li>
<li><p><strong>Instance variable</strong>: A variable that is defined inside a method and belongs only to the current instance of a class.</p></li>
<li><p><strong>Class variable</strong>: A variable that is shared by all instances of a class. Class variables are defined within a class but outside any of the class&#39;s methods. Class variables are not used as frequently as instance variables are.</p></li>
<li><p><strong>Inheritance</strong>: The transfer of the characteristics of a class to other classes that are derived from it.</p></li>
<li><p><strong>Object</strong>: A unique instance of a data structure that&#39;s defined by its class. An object comprises both data members (class variables and instance variables) and methods.</p></li>
</ul>

<h2 id="why-use-classes?">Why use classes?</h2>

<p>Programming using OOP is really just a preference- <a href="http://cs.lmu.edu/%7Eray/notes/paradigms/">there are other paradigms</a> that can accomplish the same thing, some being better suited to certain problems than others. <a href="http://c2.com/cgi/wiki?ArgumentsAgainstOop">While there are some strong opinions against it,</a> OOP can make some problems conceptually easier to understand and visualize. Among the things that using classes do for you:  </p>

<ul>
<li>Provide a logical grouping of functions<br></li>
<li>Allow you to share data for these functions to use<br></li>
<li>Provide a <a href="http://en.wikipedia.org/wiki/Namespace">namespace</a> for these functions and data attributes<br></li>
<li>Structure programs to provide more reusable code</li>
<li>Allows you to add new features to existing code

<ul>
<li>This point more apparent after seeing what a <strong>subclass</strong> is</li>
</ul></li>
</ul>

<p>You can accomplish the some of these things by using modules (specifically the namespace benefit), but using global variables, especially across code that will be shared and reused widely, is a bad idea. <a href="http://inventwithpython.com/blog/2014/12/02/why-is-object-oriented-programming-useful-with-an-role-playing-game-example/">More on why OOP is useful</a></p>

<h3 id="defining-your-own-class">Defining your own class</h3>

<p>Let&#39;s give a basic definition of a class:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Common base class for all employees&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
     
    <span class="k">def</span> <span class="nf">print_self</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Name : </span><span class="si">%s</span><span class="s">, Salary: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span><span class="p">)</span></code></pre></div>

<p>The first method <code>__init__()</code> is a special method, which is called the <strong>class constructor</strong> or <strong>initialization method</strong>. Python calls this when you create a new instance of this class: <code>employee = Employee()</code>. This method essentially first creates an empty <code>Employee</code> object, which gets passed as the <code>self</code> to the <code>__init__</code> method to be initialized. </p>

<p>After initialization, you access class and instance methods with dot notation: <code>employee.name = &#39;Scott&#39;</code>. To specify the name and salary of the employee right away, you use <code>employee = Employee(&#39;Scott&#39;, &#39;10000&#39;)</code>. </p>

<p>You declare other class methods like normal functions with the exception that the first argument to each method is <code>self</code>.  You do not need to include it when you call the methods. If you make an instance then calling <code>employee.print_self()</code> implicitly adds the <code>self</code> to the argument list. The function has access to all properties of that instance (<code>name</code> and <code>salary</code> above) as well as all <strong>class variables</strong>.</p>

<h3 id="class-variables">Class variables</h3>

<p>We can also add data to a class that will be shared among <strong>all</strong> instances created:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Common base class for all employees&#39;&#39;&#39;</span>
    <span class="n">employee_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
        <span class="n">Employee</span><span class="o">.</span><span class="n">employee_count</span> <span class="o">+=</span> <span class="mi">1</span>
     
    <span class="k">def</span> <span class="nf">print_self</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Name : </span><span class="si">%s</span><span class="s">, Salary: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span><span class="p">)</span></code></pre></div>

<p>The variable <code>employee_count</code> can be accessed inside the class or outside the class. This means you can call <code>employee.employee_count</code>, as you can for any normal class attribute, <em>or</em> <code>Employee.employee_count</code>, where the second is only true of class variables.</p>

<h3 id="class-methods-vs-instance-methods">Class methods vs instance methods</h3>

<p>Similar to class variables, you can also define <strong>class methods</strong>:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Common base class for all employees&#39;&#39;&#39;</span>
    <span class="n">employee_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
        <span class="n">Employee</span><span class="o">.</span><span class="n">employee_count</span> <span class="o">+=</span> <span class="mi">1</span>
   
    <span class="k">def</span> <span class="nf">print_self</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Name : </span><span class="si">%s</span><span class="s">, Salary: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">display_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Total Employees: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">Employee</span><span class="o">.</span><span class="n">employee_count</span></code></pre></div>

<p>This can be accessed by the instance like a normal method or by calling <code>Employee.display_count</code>. Note that once you have defined a class, you can call this method <em>before any instances are created</em>.</p>

<h2 id="inheritance">Inheritance</h2>

<p>The real usefulness of classes come in when you get into <strong>inheritance</strong>. This is where you take a preexisting class make a <strong>subclass</strong> or <em>derived class</em> from it:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Analyst</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Subclass of the Employee&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">20000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
        <span class="n">Employee</span><span class="o">.</span><span class="n">employee_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">speak_analyst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Let&#39;s make some graphs&quot;</span></code></pre></div>

<p>Notice that now instead of <code>object</code> as the argument passed to the class name, it&#39;s the base class <code>Employee</code> (<code>object</code> is used as Python makes a switch from older Python classes to &#39;new-style&#39; classes. <a href="http://stackoverflow.com/questions/4015417/python-class-inherits-object">See here for more</a>)<br>
This <code>Analyst</code> class has an init function and only defines one new method, <code>speak_analyst</code>. However, because it inherited from <code>Employee</code>, it inherits <em>all methods from it as well</em> (except for those it redefines). This means that the following are all valid:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Sam&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">salary</span>
<span class="mi">10000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">employee_count</span>
<span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Analyst</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Scott&#39;</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">30000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">speak_analyst</span><span class="p">()</span>
<span class="n">Let</span><span class="s">&#39;s make some graphs</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">salary</span>
<span class="mi">30000</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">employee_count</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">employee_count</span>
<span class="mi">2</span></code></pre></div>

<p>Notice both the shared methods from the base class <em>and</em> the chared class attribute, <code>employee_count</code> that works from an <code>Analyst</code> instance. Also note that the new <code>Analyst</code> increased the <code>employee_count</code> of both <code>Employee</code> and <code>Analyst</code>. This however can be a dangerous way to implement shared data, as directly changing this attribute on an instance can cause it to lose track of the <code>employee_count</code> when others are created (it has overwritten the class attribute.)</p>

<p>Since the two classes above have the same <code>__init__</code> methods, we can shorten the <code>Analyst</code> definition a bit:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Analyst</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Subclass of the Employee&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">20000</span><span class="p">):</span>
        <span class="n">Employee</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">salary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">speak_analyst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Let&#39;s make some graphs&quot;</span></code></pre></div>

<p>There is also a <code>super</code> method which can provide an alternate syntax (which becomes even cleaner in Python 3):</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Analyst</span><span class="p">(</span><span class="n">Employee</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Subclass of the Employee&#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">salary</span><span class="o">=</span><span class="mi">20000</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Analyst</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">salary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">speak_analyst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Let&#39;s make some graphs&quot;</span></code></pre></div>

<p>This will do the exact same thing as the previous <code>Employee.__init__(...)</code> above. The use of <code>super</code> does not really come in until you start using <strong>multiple inheritances</strong>, where a single class is subclassed from two parent classes. <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=236275">Read more about <code>super</code> here.</a></p>

<h3 id="overloading-methods">Overloading methods</h3>

<p>In OOP, <strong>function overloading</strong> is the assignment of more than one behavior to a particular function. The operation performed varies by the types of objects or arguments involved.<br>
If your class has a special way you want to perform a builtin operation- say, addition- then you can explicitly define that and override it for your class:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Vector</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>

<span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>

<span class="o">&gt;&gt;</span> <span class="n">Vector</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></code></pre></div>

<h2 id="python-specific-class-features">Python-specific Class Features</h2>

<p>OOP has uses in most languages, but Python has some pecularities in its class implementation.</p>

<h3 id="public-and-private-methods">Public and Private Methods</h3>

<p>In other languages, methods and member variables can be marked as <strong>public</strong> or <strong>private</strong>. Public methods can be called and public member variables can be set by any code, inside or outside of the class. Private methods can be called and private member variables can be set only by code inside the object&#39;s own class. </p>

<p>The purpose of this is to allow the class to be something presented with a specific set of functions and attributes, and only have those be available to the user. These are the public methods. The private methods are anything that the designer of the class needs to make the public methods work properly. The user does not need to know <em>how</em> the public methods are implement, just that the <em>do</em> work exactly as described. Since good programming practice says to keep functions short and specific, breaking out complicated public methods into smaller private methods can make things logically simpler.</p>

<p>In Python, unlike other languages, no method is <em>fully</em> private. you may have seen methods start with a double underscore <code>__</code>. </p>

<p>For example, at the bottom of many modules, you may see:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span></code></pre></div>

<p>This means that when the module is run directly (typing <code>python module.py</code>), the variable <code>__name__</code> will be set to <code>__main__</code> (as opposed to if the module is imported, in which case <code>__name__</code> will be the module you are importing into.)</p>

<p>These double underscore methods are (some of) the &#39;private&#39; methods of an object. However, these methds are always visible to the user. If you type:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span></code></pre></div>

<p>then type <code>t.__</code> and hit tab into iPython, you&#39;ll get all the <code>__</code> methods:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__add__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__format__</span>        <span class="n">t</span><span class="o">.</span><span class="n">__gt__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__mod__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__repr__</span>          <span class="n">t</span><span class="o">.</span><span class="n">__subclasshook__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__class__</span>         <span class="n">t</span><span class="o">.</span><span class="n">__ge__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__hash__</span>          <span class="n">t</span><span class="o">.</span><span class="n">__mul__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__rmod__</span>
<span class="o">...</span></code></pre></div>

<p>You can also see all methods (public and private) of an object with:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">[</span><span class="n">method</span> <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">method</span><span class="p">))]</span></code></pre></div>

<p>Even though all methods are visible, it&#39;s still useful when creating classes to use private, or at least &#39;internal&#39;, methods. <a href="https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles">The style convention</a> is to use a single underscore as a weak &quot;internal use&quot; indicator:</p>

<p>The leading and trailing double underscores in a Python <code>__method__</code> is described by the style guide as:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">... &quot;magic&quot; objects or attributes that live in user-controlled namespaces. E.g. __init__ , __import__ or __file__ . Never invent such names; only use them as documented.&#39;
</code></pre></div>
<p><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">This SO answer describes the difference between the single and double underscore methods</a>, and <a href="https://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-references">&#39;name mangling&#39; is described here.</a></p>

<h3 id="__str__-and-__repr__"><code>__str__</code> and <code>__repr__</code></h3>

<p>Both of these methods are built into classes, and both do some kind of &#39;printing&#39;.</p>

<ul>
<li>The goal of <code>__str__</code> is to be readable<br></li>
<li>The goal of <code>__repr__</code> is to be unambiguous<br></li>
</ul>

<p>As an example, you might have this for a 4x4 game board class:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">BoardState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">pieces</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,)):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pieces</span> <span class="o">=</span> <span class="n">pieces</span></code></pre></div>

<p>If you initialze an object, it will be represented like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">BoardState</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bs</span>
<span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">BoardState</span> <span class="n">at</span> <span class="mh">0x10b3c22d0</span><span class="o">&gt;</span></code></pre></div>

<p>Using <code>print</code> yeilds the same results. This is because it is using the default <code>__repr__</code> method. (which also is the default <code>__str__</code> method). It is <em>unambiguous</em> because it tells you exactly where it is in memory. However, you might want a little more detail about what is in the class.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> with pieces </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span></code></pre></div>

<p>Now you would see:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">bs</span>
<span class="o">&lt;</span><span class="k">class</span> <span class="nc">__main__</span><span class="o">.</span><span class="n">BoardState</span><span class="o">&gt;</span> <span class="k">with</span> <span class="n">pieces</span> <span class="p">{</span><span class="s">&#39;pieces&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span></code></pre></div>

<p>However, this is still ugly on sight. To really visualize it, you might define something like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">all_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pieces</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">row_idx</span><span class="p">:</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">row_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">str_row</span> <span class="o">=</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span>
            <span class="n">all_str</span> <span class="o">+=</span> <span class="n">str_row</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="k">return</span> <span class="n">all_str</span></code></pre></div>

<p>Now when we print, it looks like this:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">bs</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span></code></pre></div>

<p>The <code>Employee</code> class above could have also implemented its <code>print_self</code> method as its <code>__str__</code> in order to call <code>print employee</code>:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Employee</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Name : </span><span class="si">%s</span><span class="s">, Salary: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span><span class="p">)</span></code></pre></div>

<p>*For a detailed explanation of <code>__repr__</code> vs <code>__str__</code>, <a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python">see here</a></p>

<h4 id="other-private-methods-of-a-class-(string-example)">Other private methods of a class (string example)</h4>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="s">&#39;foo&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__add__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__format__</span>        <span class="n">t</span><span class="o">.</span><span class="n">__gt__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__mod__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__repr__</span>          <span class="n">t</span><span class="o">.</span><span class="n">__subclasshook__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__class__</span>         <span class="n">t</span><span class="o">.</span><span class="n">__ge__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__hash__</span>          <span class="n">t</span><span class="o">.</span><span class="n">__mul__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__rmod__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__contains__</span>      <span class="n">t</span><span class="o">.</span><span class="n">__getattribute__</span>  <span class="n">t</span><span class="o">.</span><span class="n">__init__</span>          <span class="n">t</span><span class="o">.</span><span class="n">__ne__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__rmul__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__delattr__</span>       <span class="n">t</span><span class="o">.</span><span class="n">__getitem__</span>       <span class="n">t</span><span class="o">.</span><span class="n">__le__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__new__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__setattr__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__doc__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__getnewargs__</span>    <span class="n">t</span><span class="o">.</span><span class="n">__len__</span>           <span class="n">t</span><span class="o">.</span><span class="n">__reduce__</span>        <span class="n">t</span><span class="o">.</span><span class="n">__sizeof__</span>
<span class="n">t</span><span class="o">.</span><span class="n">__eq__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__getslice__</span>      <span class="n">t</span><span class="o">.</span><span class="n">__lt__</span>            <span class="n">t</span><span class="o">.</span><span class="n">__reduce_ex__</span>     <span class="n">t</span><span class="o">.</span><span class="n">__str__</span></code></pre></div>

<p><strong>lt</strong>, <strong>le</strong>, <strong>eq</strong>, <strong>ne</strong>, <strong>gt</strong> and <strong>ge</strong>: Called to compare the object with another object. These will be called if defined, otherwise Python will fall-back to using <strong>cmp</strong>.
<strong>call</strong>: Lets an object be &quot;called&quot; e.g. so that you can write things like this: obj(arg1,arg2,...).
Python also lets you define methods that let an object act like an array (so you can write things like this: <code>obj[2] = &quot;foo&quot;</code>), or like a numeric type (so you write things like this: <code>print(obj1 + 3*obj2)</code>.</p>

<h3 id="special-attributes-of-python-classes">Special Attributes of Python Classes</h3>

<p>Special attributes:  </p>

<ul>
<li><p><code>__name__</code> is the class name; </p></li>
<li><p><code>__module__</code> is the module name in which the class was defined; </p></li>
<li><p><code>__dict__</code> is the dictionary containing the class’s namespace; </p></li>
<li><p><code>__bases__</code> is a tuple (possibly empty or a singleton) containing the base classes, in the order of their occurrence in the base class list;</p></li>
<li><p><code>__doc__</code> is the class’s documentation string, or None if undefined.</p></li>
</ul>

<h3 id="the-@property-method">The @property method</h3>

<p>This is used to define setters and getters of class attributes. For example,</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">audience_selected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="s">&#39;audience&#39;</span><span class="p">][</span><span class="s">&#39;selected&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span></code></pre></div>

<p>This now allows us to call <code>self.audience_selected</code>, which is easier to call than the double nested call in the method. If we wrote</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="nd">@audience_selected.setter</span>
<span class="k">def</span> <span class="nf">audience_selected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">counters</span><span class="p">[</span><span class="s">&#39;audience&#39;</span><span class="p">][</span><span class="s">&#39;selected&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code></pre></div>

<p>We would have a setter for <code>self.audience_selected = value</code></p>

<p>Another example, where the <code>temperature</code> attribute is protected from ill-advised tampering by a user:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Celsius</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature</span> <span class="o">=</span> <span class="n">temperature</span>

    <span class="k">def</span> <span class="nf">to_fahrenheit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">*</span> <span class="mf">1.8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">32</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Getting value&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temperature</span>

    <span class="nd">@temperature.setter</span>
    <span class="k">def</span> <span class="nf">temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">273</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Temperature below -273 is not possible&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Setting value&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temperature</span> <span class="o">=</span> <span class="n">value</span></code></pre></div>

<p>Now the user cannot set a temperature below -273, or they will et a <code>ValueError</code>.</p>

<h2 id="final-notes">Final Notes</h2>

<p>This was meant as an overview to many different parts of classes in Python. Since object oriented design is a very large field of study, learning to implement good classes in programs takes time, and often comes only after learning about other languages which use OOP principles.</p>

    </div>
    <div id="footer">
      <script>
      $(function() {
  return $("h2, h3, h4, h5, h6").each(function(i, el) {
    var $el, icon, id;
    $el = $(el);
    id = $el.attr('id');
    icon = '<i class="fa fa-link"></i>';
    if (id) {
      return $el.prepend($("<a />").addClass("header-link").attr("href", "#" + id).html(icon));
    }
  });
});

      </script>
    </div>
  </body>
</html>
