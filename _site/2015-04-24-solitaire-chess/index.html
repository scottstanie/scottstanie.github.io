<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Breadth First Search in Python</title>
     <link rel="stylesheet"
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <style type="text/css" media="screen">
      body {
        background:white; color:#020202;
        font:1.5rem georgia, serif;
        line-height:1.4;
        font-weight: lighter;
        text-rendering: optimizelegibility;
      }
      div.breaker { clear:both; }
      img { border:none; vertical-align:bottom; }
      hr { height:1px; border:none; background-color:#ddd; }
      h1,h2,h3,h4 {
        font-family: 'Helvetica Neue', helvetica, sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      #content {
        padding:20px;
      }
      table {
  margin:0;padding:0;
  width:100%;
  box-shadow: 10px 10px 5px #888888;
  border:1px solid #000000;

  -moz-border-radius-bottomleft:0;
  -webkit-border-bottom-left-radius:0;
  border-bottom-left-radius:0;
}

.header-link {
  position: absolute;
  left: 0em;
  opacity: 0;

  -webkit-transition: opacity 0.2s ease-in-out 0.1s;
  -moz-transition: opacity 0.2s ease-in-out 0.1s;
  -ms-transition: opacity 0.2s ease-in-out 0.1s;
}

h2:hover .header-link,
h3:hover .header-link,
h4:hover .header-link,
h5:hover .header-link,
h6:hover .header-link {
  opacity: 1;
}



      .hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.il { color: #666666 } /* Literal.Number.Integer.Long */

    </style>
  </head>
  <body>
    <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="/">Scott Staniewicz</a>
    </div>
    <div>
      <ul class="nav navbar-nav">
        <li class="active"><a href="/">Home</a></li>
        <li><a href="/posts">Posts</a></li>
        <li><a href="/about">About</a></li>
        <li><a href="/projects">Projects</a></li>
      </ul>
    </div>
  </div>
</nav>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <div id="content">
      <h1 id="breadth-first-search-in-python-using-solitaire-chess">Breadth First Search in Python, using Solitaire Chess</h1>

<p>Here is an example of Breadth First Search (BFS) to traverse a graph and find all possible paths. The graph here is a representation of a 4x4 chess board in the game of <a href="http://www.thinkfun.com/microsite/solitairechess/demo">solitaire chess</a>. The pieces are standard chess pieces. The only legal moves are captures of other pieces. Pawns only being able to move downward.<br>
The board starts in a random configuration, and the objective of the puzzle is to be left with only one piece.<br>
An interesting programming problem related to this game: Create a program that can accept an arbitrary board state as input and determine if there is a solution. If there are solutions, print out all steps for each one.<br>
The steps to programming this solution are as follows:
1. Create classes for each type of piece, with methods for the available move directions that test for boundaries
2. Create a class for the board state with the methods to find all available moves from the current state. Include an attribute for marking the parent of the board state- that is, which board came before the current one, with <code>None</code> as the parent of the starting board.
3. For the BFS, create a queue (from <code>collections.deque</code>) to store the board states for testing each one. As new board states are found from each one tested, push them on to the back of the queue.</p>

<p>The actual BFS algorithm looks like this, where <code>Board_state.size()</code> is a method to list how many pieces are left on the board, and <code>Board_state.win_paths</code> is list of the indices to keep track of which winning paths the state was a part of.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def run_BFS(start_board, queue):
    all_boards = []
    win_idx = 0

    queue.append(start_board)

    while len(queue) &gt; 0:
        cur = queue.popleft()
        all_boards.append(cur)

        if cur.size() &gt; 1:
            new_boards = cur.find_all_captures()
            queue.extend(new_boards)
        else:
            cur.win_paths.append(win_idx)
            win_idx += 1

    num_strategies = win_idx

    return all_boards, num_strategies
</code></pre></div>
<h4 id="depth-first-search">Depth first search</h4>

<p>Depth first search on the other hand looks like the following/</p>

<ol>
<li>Start with a node to search from, and mark it as &#39;searched&#39;</li>
<li>Visit one of the neighboring nodes and mark it</li>
<li>Visit some neighbor node until there are none you haven&#39;t visited, then go to next neighbor node from (2)</li>
<li>Continue until the goal is found or all are marked</li>
</ol>

<p>If we were to use Depth First Search (DFS), the algorithm would look like this:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def run_DFS(start_board, stack):
    stack.append(start_board)

    all_boards = []
    win_idx = 0

    while len(stack) &gt; 0:
        cur = stack.pop()
        all_boards.append(cur)

        if cur.size() &gt; 1:
            new_boards = cur.find_all_captures()
            stack.extend(new_boards)
        else:
            cur.win_paths.append(win_idx)
            win_idx += 1

    num_strategies = win_idx

    return all_boards, num_strategies
</code></pre></div>
<p>The main difference here is that we are using stack instead of a queue, though in python they can be the same data structure- a deque. The deque and a normal <code>list</code> would be the same here, as we are simply popping graph nodes on top of the stack and removing one at each iteration.<br>
The difference in DFS is that the nodes that were most recently placed on top are examined first, leading to some solution along a path quicker. If we were to stop at the first possible solution, DFS would be usually be quicker (unless the one solution were the last branch of the graph).</p>

    </div>
    <div id="footer">
      <script>
      $(function() {
  return $("h2, h3, h4, h5, h6").each(function(i, el) {
    var $el, icon, id;
    $el = $(el);
    id = $el.attr('id');
    icon = '<i class="fa fa-link"></i>';
    if (id) {
      return $el.prepend($("<a />").addClass("header-link").attr("href", "#" + id).html(icon));
    }
  });
});

      </script>
    </div>
  </body>
</html>
